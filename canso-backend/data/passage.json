{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1689602470763929602",
        "title": "java学习之认识异常",
        "description": null,
        "content": "## 异常处理概述\n\n1. **异常（理解）**\n   - (1) 程序出现的不正常的情况。\n   - (2) 异常分类\n     - `Throwable`\n       - `Error`: 严重的问题(修改代码逻辑)\n       - `Exception`\n         - `RuntimeException`: 可以处理，也可以不处理。一般就是程序出问题了，需要改程序。\n         - 非`RuntimeException`: 需要进行处理，否则编译不通过。\n   - (3) JVM的默认处理方案\n     - 把异常的类名、原因和位置等信息输出在了控制台。\n     - 会在哪里跌倒哪里坐下来。程序停止。\n   - (4) 自己处理异常的方案\n     - A: `try...catch...finally`\n       - 变形:\n         - `try...catch...`\n         - `try...catch...catch...catch...`\n         - `try...catch...finally`\n         - `try...catch...catch...catch...finally`\n         - `try...finally`\n     - B: `throws`\n       - 把问题抛出\n     - 建议使用A处理方案。实在解决不了，使用B方案。\n   - (5) 编译时期异常和运行时期异常的区别\n     - A: 编译时期异常：必须处理，否则程序不能通过编译。\n     - B: 运行时期异常：可以处理，也可以不处理。一般不处理。\n   - (6) `throws`和`throw`的区别\n     - A: `throws`\n       - 方法声明上，后面跟的是类名，用逗号隔开，表示可能有异常。\n     - B: `throw`\n       - 方法体中，后面跟的是对象名，只能跟一个，表示有一个异常产生。\n   - (7) `finally`的面试题\n     - A: 特点及注意事项\n       - a: 被`finally`控制的代码永远会执行。\n       - b: 注意：在执行`finally`之前JVM退出了，就不会执行了。\n     - B: `final`、`finally`和`finalize`的区别\n   - C: 如果`catch`里面有`return`，`finally`还执行吗？如果执行，在`return`前还是后。\n\n### Throwable、Error、Exception 的区别\n\n在 Java 中，`Throwable`、`Error` 和 `Exception` 是三个重要的类，用于处理程序中的异常情况。它们之间的区别如下：\n\n1. **Throwable**：\n   - `Throwable` 是 Java 中所有异常的根类，它是一个顶层的异常类，其他异常类都直接或间接地继承自它。\n   - `Throwable` 有两个主要的子类：`Error` 和 `Exception`。\n\n2. **Error**：\n   - `Error` 表示严重的错误，通常是由于虚拟机运行环境出现了无法恢复的问题。\n   - 例子包括：`OutOfMemoryError`（内存不足）、`StackOverflowError`（栈溢出）等。\n   - 一般情况下，应用程序无法处理 `Error`，因为这些错误通常是系统级别的问题，程序无法从中恢复。因此，开发人员一般不会捕获或处理 `Error`。\n\n3. **Exception**：\n   - `Exception` 表示一般性的异常情况，可以被程序处理。\n   - `Exception` 又分为两类：`RuntimeException` 和非 `RuntimeException`。\n   - `RuntimeException`：这是一类特殊的异常，通常是由程序逻辑错误引起的，例如空指针异常（`NullPointerException`）、数组越界异常（`IndexOutOfBoundsException`）等。这些异常是可以通过编写更好的代码来避免的，因此 Java 不要求必须显式地捕获或处理它们。\n   - 非 `RuntimeException`：这些异常通常是由外部因素引起的，例如文件找不到异常（`FileNotFoundException`）、网络连接异常（`IOException`）等。这些异常是需要在代码中显式处理的，否则编译会出错。\n\n总之，`Throwable` 是异常体系的根类，`Error` 表示严重错误，通常无法处理，而 `Exception` 表示一般性的异常情况，分为可以不处理的 `RuntimeException` 和需要处理的非 `RuntimeException`。在实际编程中，应该根据具体情况选择捕获和处理异常。\n\n\n#### 说说throw和throws的区别(面试题)\n\n```java\nthrows:\n(1)声明抛出异常，方法本身不处理异常，而是提醒调用者处理。\n(2)定义方法时，用在方法的定义形式上\n(3)throws 用于提醒方法调用者，方法可能出现异常，也可能不出现异常。\n\nthrow: \n(1)手动抛出异常，程序员根据程序的逻辑手动抛出一个具体的异常对象。throw 异常对象;\n(2)用在方法内\n(3)如果遇到throw 方法内部一定产生异常。\n    \n```\n   \n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 6,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-10T11:39:54.000+00:00",
        "updateTime": "2023-08-11T17:37:08.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-04T00:45:29.000+00:00"
        },
        "tags": [
          "文章",
          "笔记",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1689274831431901186",
        "title": "java学习之集合-day02",
        "description": null,
        "content": "# Java集合框架中的Set接口和实现类\n\n## Set接口概述和特点\n\nSet接口是Java集合框架中的一部分，它继承自Collection接口。Set接口的特点包括：\n\n- **不允许重复元素：** Set中不能包含重复的元素，每个元素在Set中只能出现一次。\n- **无序性：** Set不保证元素的顺序，不同的实现类可能以不同的方式存储和遍历元素。\n- **允许null元素：** 大多数Set实现允许添加一个null元素，但某些实现可能不支持。\n\n## Set接口实现类\n\nJava中常见的Set接口的实现类有：\n- **HashSet:** 基于哈希表实现，提供快速的插入、删除和查找操作。元素无序存储。\n- **TreeSet:** 基于红黑树实现，元素按照自然顺序或指定的Comparator进行排序。\n\n## HashSet类\n\n### 基本使用\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        HashSet<String> set = new HashSet<>();\n        \n        set.add(\"apple\");\n        set.add(\"banana\");\n        set.add(\"orange\");\n        \n        System.out.println(set); // 无序输出：[orange, banana, apple]\n        \n        set.remove(\"banana\");\n        System.out.println(set); // [orange, apple]\n        \n        System.out.println(\"Contains 'apple': \" + set.contains(\"apple\")); // true\n        System.out.println(\"Size: \" + set.size()); // 2\n    }\n}\n```\n## 哈希表工作原理\n\nHashSet基于哈希表实现，它使用了哈希函数将元素映射到数组的索引位置。具体工作原理涉及哈希码、散列冲突解决（如链地址法）等概念。\n\n### HashSet存储自定义对象\n\n为了在HashSet中存储自定义对象，您需要确保自定义类正确实现了`equals()`和`hashCode()`方法，以便保证元素的唯一性和正确的哈希计算。\n\n## TreeSet类\n\n### 基本使用\n\n```java\nimport java.util.TreeSet;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        TreeSet<Integer> set = new TreeSet<>();\n        \n        set.add(5);\n        set.add(2);\n        set.add(8);\n        \n        System.out.println(set); // 有序输出：[2, 5, 8]\n        \n        set.remove(5);\n        System.out.println(set); // [2, 8]\n        \n        System.out.println(\"First element: \" + set.first()); // 2\n        System.out.println(\"Last element: \" + set.last()); // 8\n    }\n}\n```\n\n## TreeSet工作原理\n\nTreeSet基于红黑树实现，红黑树是一种自平衡二叉搜索树。它保持元素有序，插入、删除和查找操作的平均时间复杂度都是O(log n)。\n\n### Comparable接口和Comparator接口\n\n要在TreeSet中存储自定义对象，需要确保元素类实现了Comparable接口或提供一个Comparator对象用于元素的比较。\n\n```java\nimport java.util.TreeSet;\nimport java.util.Comparator;\n\nclass Person implements Comparable<Person> {\n    String name;\n    int age;\n    \n    // Constructors, getters, setters\n    \n    @Override\n    public int compareTo(Person other) {\n        return this.name.compareTo(other.name);\n    }\n}\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        TreeSet<Person> set = new TreeSet<>(Comparator.comparingInt(p -> p.age));\n        \n        set.add(new Person(\"Alice\", 25));\n        set.add(new Person(\"Bob\", 30));\n        set.add(new Person(\"Charlie\", 22));\n        \n        System.out.println(set); // 按照年龄排序输出\n    }\n}\n```\n\n## Comparable接口和Comparator接口的作用和区别?\n\n### Comparable接口\n- `Comparable`接口是Java提供的一个用于自然排序的接口。\n- 当一个类实现了`Comparable`接口，它必须实现`compareTo`方法，该方法用于定义对象之间的自然顺序关系。\n- 实现了`Comparable`接口的对象可以通过`Collections.sort`方法或`Arrays.sort`方法进行排序。\n\n### Comparator接口\n- `Comparator`接口是用于比较两个对象的接口，不需要修改源代码，可以灵活地定义多种不同的比较规则。\n- 实现了`Comparator`接口的类需要实现`compare`方法，该方法用于定义对象之间的比较规则。\n- `Comparator`对象可以作为参数传递给各种排序方法，如`Collections.sort`和`Arrays.sort`。\n\n#### 区别\n- `Comparable`接口在类的定义时指定排序逻辑，适用于对类的自身属性进行排序。\n- `Comparator`接口则是在需要排序的时候提供一个比较器，适用于在不修改类定义的情况下定义多种不同的排序方式。\n\n## Map集合的使用场景\n\n`Map`是Java集合框架中的一种数据结构，用于存储键值对。以下是`Map`集合的一些使用场景：\n\n1. **存储关联数据：** 适用于需要存储一对一关系的数据，如字典、映射关系等。\n2. **数据缓存：** 可以使用`Map`集合来缓存计算结果或数据，以提高性能。\n3. **查找表：** 适用于构建查找表，通过键快速查找对应的值。\n4. **计数器：** 可以用`Map`集合实现计数器功能，统计元素出现的次数。\n\n## Map集合中元素的增删改查\n\n### 增加元素\n\n```java\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"apple\", 3);\nmap.put(\"banana\", 5);\n//删除元素\nmap.remove(\"apple\");\n//修改元素\nmap.put(\"banana\", 10); // 更新键\"banana\"对应的值\n//查找\nint count = map.getOrDefault(\"apple\", 0);\n// 获取键\"apple\"对应的值，如果不存在返回默认值0\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-09T13:57:59.000+00:00",
        "updateTime": "2023-08-11T17:40:05.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-04T00:45:29.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1688143523863396354",
        "title": "java学习之常用类-数组操作",
        "description": null,
        "content": "## 数组元素拷贝的逻辑?\n\n通过循环遍历原数组的每个元素，并将其逐个复制到目标数组中。\n\n## 数组元素冒泡排序的原理?\n- 比较相邻的两个元素。如果第一个元素比第二个元素大（或者按照升序排序的要求，如果第一个元素比第二个元素小），则交换这两个元素的位置。\n\n- 对数组中的每一对相邻元素执行步骤1。这样一轮遍历结束后，最后的元素将是数组中的最大元素（或最小元素，取决于排序顺序）。\n\n- 重复步骤1和步骤2，每次遍历减少一个元素，直到没有任何需要交换的元素，即数组已经按照指定顺序排列。\n\n**总结:** 每次遍历都把最大（或最小）的元素冒泡到未排序的最后，不断重复这个过程直到整个数组有序。\n\n## 数组元素的二分法查找的原理?\n**前提:** 查找的数组里的元素必须为有序元素\n\n1. 确定查找范围：首先，需要确定要查找的元素所在的范围。初始时，整个数组就是查找范围，即最小索引为0，最大索引为数组长度减1。\n\n2. 计算中间索引：找到查找范围的中间位置，计算中间索引。可以通过以下公式计算：mid = (low + high) / 2，其中low为查找范围的最小索引，high为查找范围的最大索引。\n\n3. 比较目标值：将目标值与中间位置的元素进行比较。如果目标值等于中间位置的元素，则查找成功，返回中间索引。如果目标值小于中间位置的元素，则在左侧的子数组中继续查找。如果目标值大于中间位置的元素，则在右侧的子数组中继续查找。\n\n4. 更新查找范围：根据比较结果，更新查找范围。如果目标值小于中间位置的元素，说明目标值可能在左侧的子数组中，此时将high更新为mid - 1；如果目标值大于中间位置的元素，说明目标值可能在右侧的子数组中，此时将low更新为mid + 1。然后回到步骤2，继续查找。\n\n5. 重复查找直至找到目标值或确定不存在：重复步骤2、步骤3和步骤4，直至找到目标值，此时返回目标值索引，或者确定目标值不存在于数组中，返回一个特定的标识（通常是负数）表示未找到。\n\n## 如何使用Arrays中的方法完成对数组的操作?\n\n**前提:** 要明确需求,即我们需要怎么操作数组?\n\n1. 使用官方文档(API)或第三方译本,去找到我们需要的功能方法.\n2. 通过IDEA阅读Arrays工具类源码,通过对应功能的单词查找(记住常用单词).\n3. 通过搜索软件或ChatGPT等工具,通过需求查找相应的功能用法.\n\n\n#### Arrays工具类常用方法:\n\n| 类型       | 构造器            | 方法                                                         | 描述                                                         |\n| ---------- | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|   Arrays  | Arrays()          | -                                                            | Arrays类没有公共构造器，因为Arrays类是一个工具类，不应该被实例化。 |\n|        |                  | `void sort(int[] array)`                                     | 对整型数组进行升序排序。                                      |\n|       |                  | `void sort(int[] array, int fromIndex, int toIndex)`         | 对数组的指定范围进行升序排序，包括fromIndex，但不包括toIndex。 |\n|        |                  | `int binarySearch(int[] array, int key)`                    | 使用二分法在已排序的整型数组中查找指定元素的索引。如果找到，返回元素的索引；如果未找到，返回负数。 |\n|       |                  | `int binarySearch(int[] array, int fromIndex, int toIndex, int key)` | 在指定范围内使用二分法查找指定元素的索引。                    |\n|      |                  | `int[] copyOf(int[] original, int newLength)`               | 复制原数组的前newLength个元素到一个新数组中。如果newLength大于原数组长度，将用0填充多出的部分。 |\n|      |                  | `int[] copyOfRange(int[] original, int from, int to)`       | 复制原数组的指定范围内的元素到一个新数组中。包括from索引处的元素，但不包括to索引处的元素。 |\n|       |                  | `void fill(int[] array, int value)`                          | 将整型数组中的所有元素设置为指定的值。                       |\n|        |                  | `void fill(int[] array, int fromIndex, int toIndex, int value)` | 将整型数组中指定范围内的元素设置为指定的值。    |\n\n\n\n### 数组的增删改查功能的思路\n\n容器创建:\n\n    private Object[]  players;//Object类型的数组，可以存储任何类型的对象。\n    private int size; //记录真实元素的个数:跟踪ArrayList中有效元素的个数，\n    //因为在数组中可能存在无效数据（null元素），\n    //所以使用size来标记实际有效元素的位置。\n\n    public ArrayList(int capacity) {\n        if(capacity <0){\n\n        }\n        this.players = new Object[capacity];//通过传进来的容量,创建Object对象\n    }\n\n    public ArrayList() {\n        this(10);//默认的容量\n    }\n\n\n添加\n\n    public void add(Object ele){\n        //增加的元素;size记录了数组中真实元素的个数，添加了一个元素后，size需要增加。\n        players[size++] =ele;\n        //扩容\n    // 1-> 判断扩容时机;players.length表示当前数组的容量（数组的长度）\n    // 2-> 将原数组复制到更大容量的数组中,重新赋值给原数组\n    if (size == players.length) {\n        players=Arrays.copyOf(players,players.length*2+2);\n        }\n     }\n\n删除\n\n    public void delete(int index){\n        //通过索引去查找需要删除的元素\n        //判断该索引是否在有效数据范围内\n        if (index <0 ||index>=size){\n            System.out.println(\"索引越界\");\n            return;\n        }\n        //size减一的原因:如果原数组没有发生过扩容,则可能会索引越界\n        for (int i = index; i <size-1 ; i++) {\n            players[i]=players[i+1];//如果没发生过扩容,就越界.\n        }\n        players[size]=null;//把删除的位置赋值为null;\n        size--;//删除后将有效数据减少\n        \n    }\n修改\n\n     public  void update(int index,Object num){\n        if (index <0 ||index>=size){\n            System.out.println(\"索引越界\");\n            return;\n        }\n        //根据传入的索引和修改值赋值给数组该索引位置\n        players[index] =num;\n    }\n\n查询\n\n    public Object getIndex(int index){\n    //先判断索引是否越界\n        if (index <0 ||index>=size){\n            System.out.println(\"索引越界\");\n            return null;\n        }\n        //读取该索引数组元素的内容并返回\n        return players[index];\n    }\n\n打印\n\n    //重写toString 打印有效数据(真实元素)\n        public String toString() {\n        if(size == 0){\n            return \"[]\";\n        }\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"[\");\n        for (int i = 0; i < size; i++) {//通过真实元素的个数确定拼接的元素\n            stringBuilder.append(players[i]).append(\",\");\n        }\n        stringBuilder.deleteCharAt(stringBuilder.length()-1);//删除最后拼接的\",\"\n        stringBuilder.append(\"]\");\n        return stringBuilder.toString();\n    }\n\n\n \n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 11,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-06T11:02:34.000+00:00",
        "updateTime": "2023-08-10T01:42:24.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-04T00:45:29.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端",
          "笔记"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1686690187289038850",
        "title": "java学习面向对象-类与对象-day04",
        "description": null,
        "content": "## this的作用是什么？都有哪些用途？\n\n#### this 是一个关键字，在Java中用于指代当前对象实例。它有以下主要作用和用途：\n\n- 引用当前对象：this 关键字用于在类的实例方法中引用当前对象。在方法内部，您可以使用 this 来访问当前对象的成员变量和方法。\n- 调用当前对象的方法：this 关键字可以用于在实例方法中调用当前对象的其他方法。这样可以避免与方法参数或局部变量名称产生混淆。\n- 构造函数重载：在构造函数中，如果需要调用该类的其他构造函数来初始化对象，可以使用 this 关键字。\n- 区分成员变量和局部变量：在方法中，如果成员变量和方法参数（或局部变量）具有相同的名称，可以使用 this 来区分。\n- 在内部类中访问外部类：当在一个内部类中存在与外部类同名的成员变量或方法时，使用 this 关键字可以访问外部类的成员。\n\n**总结:this 关键字在 Java 中主要用于引用当前对象实例，解决命名冲突问题，构造函数重载，以及在内部类中访问外部类的成员。使用 this 关键字可以提高代码的可读性，避免歧义，并使得代码更加清晰和易于理解。**\n\n## super的作用是什么？都有哪些用途？\n\nsuper 是一个关键字，在Java中用于引用父类的成员（包括构造函数和方法）\n\n- 访问父类的成员：在子类中，可以使用 super 关键字来引用父类的成员变量和方法。这允许子类访问父类的实现，并在此基础上进行扩展或重写。\n- 调用父类的构造函数：在子类的构造函数中，可以使用 super 关键字来调用父类的构造函数，以便在子类对象初始化时先执行父类的构造函数。\n- 在内部类中访问外部类的同名成员：当在内部类中存在与外部类同名的成员变量或方法时，使用 super 关键字可以访问外部类的成员。\n\n\n**总结:super 关键字在 Java 中主要用于访问父类的成员，调用父类的构造函数，以及在内部类中访问外部类的同名成员。使用 super 关键字可以使代码更加灵活和可扩展，同时充分利用继承和多态的特性。**\n\n## static的作用和使用场景\n### static 是一个关键字，在Java中有多种用途，它主要用于定义类级别的成员，而不是实例级别的成员。\n\n- 静态成员变量：使用 static 关键字定义的成员变量称为静态变量或类变量。静态变量属于类本身，而不是类的实例，因此它在所有实例之间共享。\n\n- 静态方法：使用 static 关键字定义的方法称为静态方法或类方法。静态方法不依赖于类的实例，可以直接通过类名调用，无需创建对象。\n\n- 静态块：使用 static 关键字定义的静态块用于在类加载时执行一些初始化操作。静态块在类的静态成员初始化之前执行。\n\n- 单例模式：静态方法可以用于实现单例模式，确保类只有一个实例存在。\n\n\n- *工具类：静态方法通常用于创建工具类，其中的方法不依赖于实例状态，而只是根据传入的参数进行处理。*\n\n**小结:static 关键字用于定义类级别的成员，不依赖于类的实例。静态成员在整个类的生命周期中只有一份副本，并且可以通过类名直接访问。常见的使用场景包括静态成员变量、静态方法、静态块、实现单例模式和创建工具类。请注意，过度使用静态成员可能会导致代码难以维护，应该谨慎使用。**\n\n\n## final 是一个修饰符（关键字），在Java中用于表示“最终”的含义。当使用 final 修饰某个成员（变量、方法或类）时，表示该成员的值、实现或继承关系不可改变。\n\n\n- 对变量的作用：\n        - final 修饰的变量为常量（常量也称为不可变的变量）。一旦在声明时或构造函数中赋值后，该变量的值不能再改变。\n        - final 变量必须在声明时或构造函数中进行初始化，之后不能再进行赋值。\n\n\n- 对方法的作用：\n    - final 修饰的方法为最终方法，表示该方法不可被子类重写（覆盖）。\n    - 子类无法修改 final 方法的实现，保证了方法的稳定性和一致性。\n    \n-     对类的作用：\n        - final 修饰的类为最终类，表示该类不可被继承，即不能有子类。\n        - 常见用法是将某些类设计成工具类或单例模式，防止其他类对其进行继承。\n\n- 对实例变量的作用：\n    - final 修饰的实例变量表示它的值在对象初始化后不能再被修改。这对于确保在对象生命周期内实例变量不会被改变非常有用。\n\n**小结:final 修饰符的作用是确保某个成员的不可变性、不可修改性或不可扩展性，它有助于提高代码的可靠性和安全性。在适当的情况下使用 final 可以让代码更易于维护和理解，并防止意外的改变或扩展。**\n\n\n## 静态代码块的语法和执行的时机\n##### 静态代码块是 Java 中用 static 修饰的一种特殊代码块。它用于在类加载时执行一些初始化操作。\n\n静态代码块可以在类中的任何位置定义，它们会按照在类中的顺序执行。当 JVM 加载类时，首先会执行所有静态代码块，然后再执行其他成员的初始化操作。\n\n        静态代码块的执行时机：\n         在类加载时执行：静态代码块在类加载时执行，且仅执行一次。类的加载过程是在第一次访问该类时发生的，包括创建对象、访问静态成员等。\n        顺序执行：如果一个类中定义了多个静态代码块，它们会按照在类中的顺序依次执行。\n        \n**总结：静态代码块是在类加载时执行的，仅执行一次。它可以用于执行一些类级别的初始化操作，例如初始化静态成员变量或加载静态资源。由于静态代码块在类加载时自动执行，因此适用于类级别的初始化场景.**    \n\n## 匿名内部类的作用和语法\n\n匿名内部类是一种特殊的内部类，它没有显式的类名，直接在创建对象时定义并实例化。匿名内部类通常用于实现接口或继承抽象类的情况，且只使用一次，避免为每个实现创建新的类。\n\n        实现接口或继承抽象类：匿名内部类可以用于在创建对象时实现接口或继承抽象类，并在同一处定义接口的实现或抽象类的扩展。\n\n        简化代码结构：对于一些简单的逻辑，使用匿名内部类可以避免为每个实现创建新的类，使代码更简洁。\n        \n        \n        语法：\n        匿名内部类的语法如下:\n        \n```java\n        Interface myInterface = new Interface() {\n    // 匿名内部类的实现代码\n    // 实现接口中的方法\n    };\n\n```\n\n\n    继承抽象类\n    \n```java\n\n    AbstractClass myAbstractClass = new AbstractClass() {\n    // 匿名内部类的实现代码\n    // 实现抽象类中的抽象方法\n};\n\n```\n\n**注意事项：**\n\n    匿名内部类没有显式的类名，因此无法被其他地方引用或重用。它只能在创建对象时使用，并且只能使用一次。\n    \n    匿名内部类可以访问外部类的成员和方法，也可以访问 final 或事实上为 final 的局部变量（Java 8+ 中）。\n    \n    在匿名内部类中，不能定义静态成员、静态方法或构造函数。\n    \n    当使用匿名内部类时，通常会在创建对象的同时重写抽象方法或接口方法，使代码更简洁，更集中，但也会增加代码的阅读难度，需要根据实际情况进行取舍。\n\n\n## 枚举类的作用和语法\n\n##### 枚举类（Enum Class）是一种特殊的类，用于定义一组固定的常量。枚举类的作用是将常量值集中在一个类中，提供更加简洁和可读性强的代码，避免使用普通类或整数常量来表示固定的常量值。\n\n\n**语法**\n\n\n```java\n\n        enum EnumName {\n    CONSTANT1,\n    CONSTANT2,\n    // ... 其他常量\n}\n\n```\n**枚举类的优势：**\n\n    类型安全：枚举类提供了类型安全的枚举常量，不需要担心传入无效的常量值。\n    \n    可读性强：枚举常量具有自解释性，代码更加可读和易于维护。\n    \n    唯一性：每个枚举常量在枚举类中都是唯一的，保证了常量值的唯一性。\n    \n**枚举类在实际开发中常用于表示状态、选项、日期、星期几等具有固定值的场景。使用枚举类可以增加代码的可读性，提高代码的可维护性，并避免传入无效或非预期的常量值。**\n    \n    \n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-02T10:47:32.000+00:00",
        "updateTime": "2023-08-08T17:32:58.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-04T00:45:29.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1686534260355239938",
        "title": "自我介绍",
        "description": "自我介绍",
        "content": "<p>大家好 , 我是苏麟!</p>\n   <p> &nbsp&nbsp&nbsp&nbsp目前是大二学生(双非本科)软件专业 , 大一报了培训机构(java后端方向) , 学了一些东西但感觉总是差些意思 , 希望跟着鱼皮更进一步 , 早日拿到大厂offer.\n    </p>\n &nbsp&nbsp &nbsp&nbsp  项目经历:</br>    \n    \n1. 旅游\n2. 管理系统\n3. 瑞吉外卖\n4. 尚医通\n\n也祝大家早日进大厂,得偿所愿!\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1684561774759645186/oQ8YxVOV-1911f1b9cd3641498364f0f756d3eb9e.jpg",
        "language": null,
        "viewNum": 40,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1684561774759645186",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-02T00:27:56.000+00:00",
        "updateTime": "2023-08-09T08:06:42.000+00:00",
        "user": {
          "id": "1684561774759645186",
          "planetCode": "25145",
          "userName": "苏麟",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/n6zz2N2CWO3rY0u7a2w4YsBNScsoA8cCItnWwbg91HzEStMVKYAr196WXmL8ByicHDbcTYQa7DFK1iaWmzOEwhiaQ/132",
          "gender": 1,
          "userProfile": "万般皆是命半点不由人...",
          "userRole": "vip",
          "interests": [],
          "place": "黑龙江",
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-07-27T13:16:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-07-27T13:49:59.000+00:00",
          "updateTime": "2023-08-02T00:28:17.000+00:00"
        },
        "tags": [
          "文章",
          "自我介绍"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1685845258216148993",
        "title": "面试记录",
        "description": "在知识星球分享的面经",
        "content": "### 因为像刚刚自我介绍里面说的，知识星球和编程导航是分开的，于是把这次面试也分享在编程导航！\n### \n**刷到了有分享面经的帖子，回想到唯一一次的面试，于是乎咱也分享一下，权当记录。**\n\n> 是女朋友的老师推荐的一家师兄的公司，老师突然问我们的安排，叫我们发了简历过去，然后很上心，过了许久我们没收到面试通知还帮我们催，发现是因为师兄以为我和我女朋友都要投简历，我投了，我女朋友有考公安排就没有投，在等我女朋友的简历才没有给我面试。于是乎说了之后隔天就给我打了电话！我的第一次长达22分钟的面试！接到电话手都是抖的！很震惊，但是确实在忙兼职还有暑假前期在外面旅游，没有学习，也可能确实是因为基础本身就不牢固，对概念性的理解较少，回答的不是很好，结束时师兄也总结说我基础还不够牢固，需要多加学习，还有优化一下简历，叫我坚持，多学习！总之还是很感谢女朋友还有老师还有师兄给了我一次面试的机会！废话有点多了哈哈哈，以下是面经，顺便贴上我那烂简历，可能没有什么借鉴参考性，权当记录啦\n\n1. 数组、链表的概念\n2. 对ArrayList、LinkedList的了解\n3. List、Set和Map的区别\n4. Servlet是什么？生命周期是？\n5. 介绍一下Spring \n6. 对SpringMVC的了解\n7. Spring的控制反转如何实现\n8. AOP如何实现\n9. 数据库的四个特性\n10. 对SpringBoot和Spring Cloud的了解\n11. MySQL使用了什么集成框架\n12. 介绍一下MyBatis\n\n**以上就是长达22分钟的面试，时长看来是因为我废话可能有点多了，答不到点上，权当记录**\n\n![微信图片编辑_20230731104718.jpg](https://pic.code-nav.cn/post_picture/1685172658901094401/GAxqEOQy-微信图片编辑_20230731104718.jpg)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1685172658901094401/QQdTV6U8-微信图片_20230730171359.jpg",
        "language": null,
        "viewNum": 61,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1685172658901094401",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-31T02:50:05.000+00:00",
        "updateTime": "2023-08-11T18:41:10.000+00:00",
        "user": {
          "id": "1685172658901094401",
          "planetCode": "25090",
          "userName": "coder_George",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1685172658901094401/GaUoFB2t-微信图片_20230730171359.jpg",
          "gender": 1,
          "userProfile": "目标：Java后端开发",
          "userRole": "vip",
          "interests": [],
          "place": "广东珠海",
          "birthday": "2002-04-07",
          "school": "吉林大学珠海学院",
          "major": "软件工程",
          "education": "本科",
          "graduationYear": 2024,
          "jobStatus": "求职中",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "校招",
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 1,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-07-27T02:57:58.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-07-29T06:17:25.000+00:00",
          "updateTime": "2023-08-03T12:49:44.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1684236816225406977",
        "title": "React 新官方文档，添加交互",
        "description": "使用 React 让你的页面动起来，学习一种编程思维",
        "content": "## 添加交互\n\n​\tReact 的宣言就是为了构建交互式 UI 变得轻而易举。所以添加交互是 React 的核心功能，如果你学过 JQuery，你一定知道 **命令式编程** 和 **声明式编程，**同样一段交互逻辑，可能 React 要比 JQuery 省去几十行代码，那么来系统的学习一下 React 添加交互的开发范式吧！\n\n你经常看到屏幕上的某些内容会根据用户操作进行更新。例如，单击图像库可切换不同的图像。在 React 中，随时间变化的数据称为状态。您可以向任何组件添加状态，并根据需要更新它。在本章中，您将学习如何编写处理交互、更新其状态以及随时间显示不同输出的组件。学习目录如下：\n\n1. 如何处理用户发起的事件 ？\n2. 如何让组件“记住”带有状态的信息 ？ \n3. React 如何分两个阶段更新 UI  ？\n4. 为什么状态在更改后没有立即更新  ？\n5. 如何对多个状态更新进行排队  ？\n6. 如何更新对象的状态  ？\n7. 如何更新状态数组 ？\n\n### 响应事件\n\nReact 允许您向 JSX 添加事件处理程序。事件处理程序是您自己的函数，将响应用户交互（例如单击、悬停、关注表单输入等）而触发。 内置组件仅支持 onClick 等内置浏览器事件。但是，您也可以创建自己的组件，并且给组件定义任何（语义化的，您喜欢的）属性名称。来触发交互事件，例如：\n\n```JavaScript\n// 自定义了按钮组件：Button 和工具栏组件：Toolbar，它们都有自定义的属性，例如：onClick，\n// onPlayMovie等等，父组件传值，来实现它们自己的交互逻辑\nexport default function App() {\n  return (\n    <Toolbar\n      onPlayMovie={() => alert('Playing!')}\n      onUploadImage={() => alert('Uploading!')}\n    />\n  );\n}\n\nfunction Toolbar({ onPlayMovie, onUploadImage }) {\n  return (\n    <div>\n      <Button onClick={onPlayMovie}>\n        Play Movie\n      </Button>\n      <Button onClick={onUploadImage}>\n        Upload Image\n      </Button>\n    </div>\n  );\n}\n\nfunction Button({ onClick, children }) {\n  return (\n    <button onClick={onClick}>\n      {children}\n    </button>\n  );\n}\n```\n\n###  状态：一个组件的内存\n\n我们最常见的交互就是通过操作修改屏幕显示的内容，例如：在表格中输入应更新输入字段，单击图像转盘上的“下一步”应更改显示的图像，单击“购买”将产品放入购物车。组件需要“记住”一些东西（也就是需要 useState 来存储这些会变化的状态）：当前输入值、当前图像、购物车。在React中，这种特定于组件（这里再强调一下，React 中所有都可以看成组件，无论是大到 页面根组件，页面组件，小到一个按钮组件，这些都是一个组件）的内存被称为状态。\n\nReact 中使用 hooks 来驱动视图更新，这里的状态就是：`useState Hooks`， 这里 `useState ` 返回当前状态值 和 更新 state 的设置器函数，例如：\n\n```JavaScript\n// 我们可以通过 index 获取当前状态，通过 setIndex 更新当前状态，\n// 当 index 的值变化，react 就会触发重新渲染\nconst [index, setIndex] = useState(0);\n```\n\n### 呈现和提交\n\n在您的 React 组件显示在屏幕上之前，它们必须由 React 渲染。了解这个**过程中的步骤**将有助于您思考代码是如何执行和解释其行为的。\n\n打个比方，你的组件是厨房里的厨师，用食材组装美味的菜肴。在这个场景中，React是服务员，他提出客户的请求并为他们带来订单。这个请求和服务UI的过程有三个步骤：\n\n1. 触发渲染（将用餐者的订单送到厨房）\n2. 渲染组件（在厨房准备订单）\n3. 展示到 DOM（在餐桌上把订单的菜展示摆好）\n\n![output](C:\\Users\\SnailRun\\Desktop\\临时文件\\output.png)\n\n### 状态做为一个快照\n\n这是 React 的一个核心思想，数据的更新，不是更新现在的状态变量，而是重新触发渲染，我们现在都是在写函数组件，也就是当 state 更新，就代表着，这个函数组件也就是这个函数重新执行一遍，并且是带着最新的 state 更新的，**这里值得注意的是 state 的更新是异步的**，\n\n让我通过一个类比来解释 **state 的更新是异步的**这个问题。\n\n假设你正在玩一个电子游戏，你的角色有一个生命值（HP）的状态。每次你的角色受到攻击，你都需要更新这个生命值。如果每次受到攻击，游戏都立即停下来，更新生命值，然后再继续，那么游戏的流畅度会大大降低，这会影响到游戏的体验。\n\n相反，如果游戏将所有的攻击事件收集起来，然后在一次过程中统一处理，例如在每一帧的更新时，那么游戏就可以保持流畅，玩家的体验也会更好。\n\nReact的 `useState` 就类似于这个过程。当你调用状态更新函数时，React 并不会立即更新状态和重新渲染组件。相反，它会将这个更新事件放入一个队列中，然后在一个合适的时间，如下一次渲染周期，统一处理这些更新。这样，React 就可以批量处理多个状态更新，避免不必要的渲染，从而提高应用的性能。\n\n这就是为什么我们说 React 的状态更新是“异步”的。这并不意味着它使用了 JavaScript 的异步功能（如 Promise 或者 setTimeout ），而是指 React 选择了在未来的某个时间点，而不是立即处理状态更新。\n\n### **对一系列状态更新进行排队**\n\n看例子：\n\n```JavaScript\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [score, setScore] = useState(0);\n\n  function increment() {\n    setScore(score + 1);\n  }\n\n  return (\n    <>\n      <button onClick={() => increment()}>+1</button>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <h1>Score: {score}</h1>\n    </>\n  )\n}\n```\n\n这里调用 `increment `三次，但是当我点击 +3，结果却是 +1 ，就是因为 increment 函数连续执行3次的时候，score 的值都是 1（拿到的是 state 快照，而不是最新的值），而不是 1,2,3 ，即使执行三次，得到的结果也是和 +1 的结果一致，\n\n### **更新作为状态的对象**\n\n当我们把 state 设置为一个 对象类型的时候，我们想要更新 这个对象 state，我们应该 创建一个新的对象引用，而不是去修改之前的 state，因为如果我们仅仅修改之前的state，它对象的引用还是一样，React 就检测不到 state 更新，也就不会触发页面刷新，所以 我们经常通过扩展运算符去新建对象覆盖源对象，而不是直接修改原数据的属性，这里数组也是一样的，因为在 JavaScript 中，数组就是一个特殊的对象而已，当我们遵从不可变性原理，我们在面对需要时间旅行的需求时候，也变得更加简单\n\n最后，官方推荐使用 Immer 这样不可变性的库来帮我们更高效的进行开发\n\n### END\n\n添加交互就结束啦，下一章，学习【状态管理】，学习完成后，你就知道当我们面对多个组件共享数据的时候，我们有哪些方法来快速实现我们的需求",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/r0v0pAcg-Snipaste_2023-06-27_00-36-41.png",
        "language": null,
        "viewNum": 32,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-26T16:18:43.000+00:00",
        "updateTime": "2023-08-10T03:15:03.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 11,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-07-26T16:16:55.000+00:00"
        },
        "tags": [
          "文章",
          "React",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1683090767360299010",
        "title": "零基础手把手带你阅读Redis源代码系列-ZSet底层原理详解（跳表SkipList）",
        "description": "带你阅读跳表源码",
        "content": ">之前就说了要来西索Redis，现在来辣！\n>\n>本文的部分内容参考自《小林Coding》，部分地方根据源代码进行剖析。\n>\n>Redis源码地址：https://github.com/redis/redis.git\n>\n>更多内容可以看我博客：https://cloud.tencent.com/developer/user/2871589\n\n\n## ZSet\n\n### 观其面\n\n和Set类似，但是新增了一个排序字段。\n\n![image-20230723015004842](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723015004842.png)\n\n常用操作\n\n```bash\n# 往有序集合key中加入带分值元素\nZADD key score member [[score member]...]   \n# 往有序集合key中删除元素\nZREM key member [member...]                 \n# 返回有序集合key中元素member的分值\nZSCORE key member\n# 返回有序集合key中元素个数\nZCARD key \n# 为有序集合key中元素member的分值加上increment\nZINCRBY key increment member \n# 正序获取有序集合key从start下标到stop下标的元素\nZRANGE key start stop [WITHSCORES]\n# 倒序获取有序集合key从start下标到stop下标的元素\nZREVRANGE key start stop [WITHSCORES]\n# 返回有序集合中指定分数区间内的成员，分数由低到高排序。\nZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n# 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。\nZRANGEBYLEX key min max [LIMIT offset count]\n# 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同\nZREVRANGEBYLEX key max min [LIMIT offset count]\n```\n\n运算操作\n\n```bash\n# 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积\nZUNIONSTORE destkey numberkeys key [key...] \n# 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积\nZINTERSTORE destkey numberkeys key [key...]\n```\n\n### 应用场景\n\n#### 排行榜\n\n点赞数量和内容ID相关联，最后再根据ID去查，或者异步更新也可以\n\n为什么不存全部数据？部分数据会修改，那么可能导致value伪重复，加大了业务复杂度\n\n#### 电话、姓名区间排序\n\n使用有序集合的 `ZRANGEBYLEX` 或 `ZREVRANGEBYLEX` 可以帮助我们实现电话号码或姓名的排序，我们以 `ZRANGEBYLEX` （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。\n\n**注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。**\n\n*1、电话排序*\n\n我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：\n\n```shell\n> ZADD phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\n> ZADD phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\n> ZADD phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```shell\n> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取 132 号段的号码：\n\n```shell\n> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段的号码：\n\n```shell\n> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n*2、姓名排序*\n\n```shell\n> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```shell\n> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人：\n\n```shell\n> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母 C 到 Z 的所有人：\n\n```shell\n> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n### 究其身\n\ncv完了，现在来看看源码。\n\nZset 类型的底层数据结构是由**压缩列表或跳表**实现的：\n\n- 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；\n- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；\n\n**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**\n\nlistpack和压缩列表在之前讲List的时候就已经讲过了，这里主要来讲一讲跳表。\n\n#### 跳表\n\n跳表是从链表的结构上面改进出来的，可以说是多层链表\n\n![image-20230723042434378](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723042434378.png)\n\n图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：\n\n- L0 层级共有 5 个节点，分别是节点1、2、3、4、5；\n- L1 层级共有 3 个节点，分别是节点 2、3、5；\n- L2 层级只有 1 个节点，也就是节点 3 。\n\n下面我们来看看实际的结构\n\n如上图，记录头节点和尾节点~~（图上没有，后面细说）~~，我们封装在一起，成了整个链跳表体\n\n```c\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\t// 头节点、尾节点\n    unsigned long length;\t\t\t\t\t// 跳表长度\n    int level;\t\t\t\t\t\t\t\t// 最高的层级\n} zskiplist;\n```\n\n那么节点又是怎么定义的呢？如果让我来做的话，我会用给一个数组来表示下一个节点（详细看上图），不过也确实是这样做的\n\n```c\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\t\t// 内容\n    double score;\t// 用于排序的字段，我们称之为权重\n    struct zskiplistNode *backward;\t//后向指针 前继\n    // level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\t// 每层的前向指针 后继\n        unsigned long span;\t\t// 跨度\n    } level[];\t\n} zskiplistNode;\n```\n\n这里对前向和后向进行一个解释：\n\t\t其实就是一个双链表，不过后续指针是一个指针数组，前向指针是后继，后向指针是前继\n\n那么这个跨度是啥？\n**跨度**\n\n用于**计算这个节点在跳表中的排位**。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，**从头节点点到该结点的查询路径上，将==沿途访问过==的所有层的跨度累加起来**，得到的结果就是目标节点在跳表中的排位。\n\n没懂？看上图，把这个节点前面的阶段求个前缀和，他们的结果就是跨度，也就是当前节点的编号。\n\n#### 跳表的创建\n\n```c\n// 定义最高层数 Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^64 elements */\n\n/* Create a new skiplist. */\nzskiplist *zslCreate(void) {\n    int j;\n    zskiplist *zsl;\n\n    zsl = zmalloc(sizeof(*zsl));\n    zsl->level = 1;\t\t\t// 初始只有一层\n    zsl->length = 0;\n    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);\t// 创建一个节点，节点创建在后面讲\n    // 把每一层都初始化\n    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {\n        zsl->header->level[j].forward = NULL;\n        zsl->header->level[j].span = 0;\n    }\n    // 初始化跳表\n    zsl->header->backward = NULL;\n    zsl->tail = NULL;\n    return zsl;\n}\n```\n\n#### 节点创建\n\n```c\n/* Create a skiplist node with the specified number of levels.\n * The SDS string 'ele' is referenced by the node after the call. */\nzskiplistNode *zslCreateNode(int level, double score, sds ele) {\n    zskiplistNode *zn =\n        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));\n    zn->score = score;\n    zn->ele = ele;\n    return zn;\n}\n```\n\n#### 跳表的释放\n\n```c\n/* Free a whole skiplist. */\nvoid zslFree(zskiplist *zsl) {\n    zskiplistNode *node = zsl->header->level[0].forward, *next;\n\n    zfree(zsl->header);\t// 释放头节点\n    // 在初始化的时候直接指向了第一个元素\n    while(node) {\n        next = node->level[0].forward;\n        // 释放每一个节点\n        zslFreeNode(node);\n        node = next;\n    }\n    zfree(zsl);\n}\n\n/* Free the specified skiplist node. The referenced SDS string representation\n * of the element is freed too, unless node->ele is set to NULL before calling\n * this function. */\nvoid zslFreeNode(zskiplistNode *node) {\n    sdsfree(node->ele);\t// 释放member\n    zfree(node);\t// 释放节点\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\t// s_free就是z_free\n}\n// 呃呃呃，这不解释了\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n```\n\n#### 跳表节点查询过程\n\n查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：\n\n- 如果当前节点的权重 < 要查找的权重时，跳表就会访问该层上的下一个节点。\n- 如果当前节点的权重 = 要查找的权重时，并且当前节点的 SDS 类型数据 < 要查找的数据时，跳表就会访问该层上的下一个节点。\n\n如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。\n\n举个例子，下图有个 3 层级的跳表。\n\n![image-20230723053340966](http://gd.7n.cdn.wzl1.top/typora/img/image-20230723053340966.png)\n\n如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：\n\n- 先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；\n- 但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];\n- 「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据 > 要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；\n- 「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。\n\n```c\n// 这里是查找的源码，来自下面新增节点的函数\n\tx = zsl->header;\n    //从顶层开始，遍历开始，每次移动不只是移动头节点的level，是所有节点的level，每次都是从上一次遍历到的节点开始\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\t\t//如果从头开始，跨度为0，否则累加上一层已经计算的跨度\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\t\t\t// 权值小于目标\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\t// 当前节点的memer小于目标节点\n        {\n            rank[i] += x->level[i].span;\t\t//计算跨度\n            x = x->level[i].forward;\t\t\t//到下一个索引位置\n        }\n        update[i] = x;\t\t//记录当前层开始修改的节点的位置\n    }\n```\n\n\n\n#### 新增节点\n\n```c\n/* Insert a new node in the skiplist. Assumes the element does not already\n * exist (up to the caller to enforce that). The skiplist takes ownership\n * of the passed SDS string 'ele'. */\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned long rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    serverAssert(!isnan(score));\n    x = zsl->header;\n    //从顶层开始，遍历开始，每次移动不只是移动头节点的level，是所有节点的level，每次都是从上一次遍历到的节点开始\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\t\t//如果从头开始，跨度为0，否则累加上一层已经计算的跨度\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\t\t\t// 权值小于目标\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\t// 当前节点的Memer小于目标节点\n        {\n            rank[i] += x->level[i].span;\t\t//计算跨度\n            x = x->level[i].forward;\t\t\t//到下一个索引位置\n        }\n        update[i] = x;\t\t//记录当前层开始修改的节点的位置\n    }\n    /* we assume the element is not already inside, since we allow duplicated\n     * scores, reinserting the same element should never happen since the\n     * caller of zslInsert() should test in the hash table if the element is\n     * already inside or not. */\n \t// 假设要插入的元素在跳跃表中尚不存在，因为跳跃表允许有相同的分值（score）。\n    // 再次插入相同的元素是不应该发生的，因为调用 zslInsert() 函数的调用者应该在哈希表（或其他数据结构）中先测试元素是否已经存在。\n    // 在跳跃表中，允许多个节点具有相同的分值，但它们的元素值必须不同。\n    level = zslRandomLevel();\t//随机生成一个层数\n    if (level > zsl->level) {\t\t\n        // 如果这个level达到新高，那么往上面走，走到顶全部初始化（你可以理解为对level进行扩容）\n        for (i = zsl->level; i < level; i++) {\n            rank[i] = 0;\n            update[i] = zsl->header;\n            // 新的level,那么再old_level到level之间的跨度每层都是length\n            update[i]->level[i].span = zsl->length;\n        }\n        zsl->level = level;\n    }\n    x = zslCreateNode(level,score,ele);\t// 创建一个新的节点\n    for (i = 0; i < level; i++) {\n        //插入节点（基础知识：单链表的节点插入），修改第Li层的后继\n        x->level[i].forward = update[i]->level[i].forward;\t\n        update[i]->level[i].forward = x;\n\n        /* update span covered by update[i] as x is inserted here */\n        // (rank[0] - rank[i])为新节点到前一层节点的跨度差\n        // update[i]->level[i].span 表示的是原本前一个节点到后一个节点建的跨度\n        // 这里新来了一个节点，前一个节点新节点的跨度是rank[0] - rank[i]，另外一个就互补，见一下就可以了\n        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);\n        // 修改前一个节点的跨度，但是这个节点本身也算一个系欸但，所以要加1\n        update[i]->level[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    /* increment span for untouched levels */\n    // 前面我们只修改了同层，上面的每一层因为中间多了一个，所以跨度加一\n    for (i = level; i < zsl->level; i++) {\n        update[i]->level[i].span++;\n    }\n\t// 修改x的前继指针\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\n    if (x->level[0].forward)\n        x->level[0].forward->backward = x;\t// 只修改最下面一层的\n    else\n        zsl->tail = x;\t//把x放在最后\n    zsl->length++;\n    return x;\n}\n```\n\n#### 删除节点\n\n```c\n/* Delete an element with matching score/element from the skiplist.\n * The function returns 1 if the node was found and deleted, otherwise\n * 0 is returned.\n *\n * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise\n * it is not freed (but just unlinked) and *node is set to the node pointer,\n * so that it is possible for the caller to reuse the node (including the\n * referenced SDS string at node->ele). */\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    x = zsl->header;\n    // 这里再将新增的时候讲过了\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                     sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    /* We may have multiple elements with the same score, what we need\n     * is to find the element with both the right score and object. */\n    x = x->level[0].forward;\n    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {\n        // 进行节点删除，并且把关联系欸但进行修改\n        zslDeleteNode(zsl, x, update);\n        if (!node)\n            // 把空间释放\n            zslFreeNode(x);\n        else\n            *node = x;\n        return 1;\n    }\n    return 0; /* not found */\n}\n```\n\n##### 解决连锁反应\n\n```c\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {\n    int i;\n    for (i = 0; i < zsl->level; i++) {\n        if (update[i]->level[i].forward == x) {\n            update[i]->level[i].span += x->level[i].span - 1;\n            update[i]->level[i].forward = x->level[i].forward;\n        } else {\n            update[i]->level[i].span -= 1;\n        }\n    }\n    if (x->level[0].forward) {\n        x->level[0].forward->backward = x->backward;\n    } else {\n        zsl->tail = x->backward;\n    }\n    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)\n        zsl->level--;\n    zsl->length--;\n}\n```\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1608208038794100737/cV0PL48v-image-20230723042434378.png",
        "language": null,
        "viewNum": 22,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608208038794100737",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-23T12:24:43.000+00:00",
        "updateTime": "2023-08-11T11:54:43.000+00:00",
        "user": {
          "id": "1608208038794100737",
          "planetCode": "14757",
          "userName": "Karos",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1608208038794100737/n43g3wnh-QQ截图20230220091409.png",
          "gender": 1,
          "userProfile": "爱好 唱 跳 rap和篮球\uD83C\uDFC0",
          "userRole": "vip",
          "interests": [],
          "place": "四川",
          "birthday": "2003-02-11",
          "school": null,
          "major": "物联网工程",
          "education": "本科",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": "嘉丽顿",
          "job": "后端",
          "workYear": -2,
          "direction": "后端",
          "goal": "实习",
          "github": "https://github.com/karosown",
          "blog": "https://www.wzl1.top/",
          "score": 10,
          "coin": 100,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-02T23:45:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-28T21:07:30.000+00:00",
          "updateTime": "2023-07-12T15:23:52.000+00:00"
        },
        "tags": [
          "文章",
          "Redis",
          "数据库",
          "数据结构"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "137",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "14"
  },
  "message": "ok"
}